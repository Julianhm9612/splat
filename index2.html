<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>

    <script src="TrailRenderer.js"></script>
    <style>
      body {
        font-family: Monospace;
        color: #fff;
        margin: 0px;
        overflow: hidden;
        background-image: url("./background.png");
        background-repeat: no-repeat;
        background-size: cover;
      }
    </style>
    <title>Three.js Trail Renderer</title>
  </head>
  <body>
    <div
      id="renderingContainer"
      style="position: absolute; left: 0px; top: 0px;"
    ></div>

    <script>
      var scene, renderer;
      var camera, pointLight, ambientLight;

      var options;
      var starPoints, circlePoints, planePoints;
      var trailTarget;
      var trailHeadGeometry, trail, lastTrailUpdateTime, lastTrailResetTime;
      var trailMaterial, baseTrailMaterial, texturedTrailMaterial;

      window.addEventListener(
        "load",
        function load(event) {
          window.removeEventListener("load", load, false);
          init();
        },
        false
      );

      function init() {
        simulationPause = false;
        lastTrailUpdateTime = performance.now();
        lastTrailResetTime = performance.now();

        getScreenDimensions();
        initTrailOptions();
        initScene();
        initLights();

        initSceneGeometry(function () {
          initTrailRenderers(function () {
            initRenderer();

            animate();
          });
        });
      }

      function initTrailOptions() {
        options = {
          headRed: 1.0,
          headGreen: 0.0,
          headBlue: 1.0,
          headAlpha: 0.75,

          tailRed: 0.0,
          tailGreen: 1.0,
          tailBlue: 1.0,
          tailAlpha: 0.35,

          trailLength: 100,
          //   trailType: TrailTypes.Textured,
          //   trailShape: TrailShapes.Plane,

          textureTileFactorS: 10.0,
          textureTileFactorT: 0.8,

          dragTexture: false,
          depthWrite: false,

          pauseSim: false,
        };
      }

      function initRenderer() {
        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(screenWidth, screenHeight);
        renderer.sortObjects = false;
        rendererContainer = document.getElementById("renderingContainer");
        rendererContainer.appendChild(renderer.domElement);
      }

      function initLights() {
        ambientLight = new THREE.AmbientLight(0x777777);
        scene.add(ambientLight);

        pointLight = new THREE.PointLight(0xffffff, 2, 1000, 1);
        pointLight.position.set(0, 40, 0);
        scene.add(pointLight);
      }

      function initSceneGeometry(onFinished) {
        initTrailHeadGeometries();
        initTrailTarget();

        if (onFinished) {
          onFinished();
        }
      }

      function initTrailHeadGeometries() {
        planePoints = [];
        planePoints.push(
          new THREE.Vector3(-14.0, 4.0, 0.0),
          new THREE.Vector3(0.0, 4.0, 0.0),
          new THREE.Vector3(14.0, 4.0, 0.0)
        );

        circlePoints = [];
        var twoPI = Math.PI * 2;
        var index = 0;
        var scale = 10.0;
        var inc = twoPI / 32.0;

        for (var i = 0; i <= twoPI + inc; i += inc) {
          var vector = new THREE.Vector3();
          vector.set(Math.cos(i) * scale, Math.sin(i) * scale, 0);
          circlePoints[index] = vector;
          index++;
        }

        starPoints = [];
        starPoints.push(new THREE.Vector3(0, 16));
        starPoints.push(new THREE.Vector3(4, 4));
        starPoints.push(new THREE.Vector3(16, 4));
        starPoints.push(new THREE.Vector3(8, -4));
        starPoints.push(new THREE.Vector3(12, -16));
        starPoints.push(new THREE.Vector3(0, -8));
        starPoints.push(new THREE.Vector3(-12, -16));
        starPoints.push(new THREE.Vector3(-8, -4));
        starPoints.push(new THREE.Vector3(-16, 4));
        starPoints.push(new THREE.Vector3(-4, 4));
        starPoints.push(new THREE.Vector3(0, 16));
      }

      function initTrailTarget() {
        var geometry = new THREE.CircleGeometry(5, 32);
        var material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        trailTarget = new THREE.Mesh(geometry, material);
        trailTarget.position.set(0, 0, 0);
        trailTarget.scale.multiplyScalar(1);
        trailTarget.receiveShadow = false;

        scene.add(trailTarget);
      }

      function initTrailRenderers(callback) {
        trail = new THREE.TrailRenderer(scene, false);

        baseTrailMaterial = THREE.TrailRenderer.createBaseMaterial();

        var textureLoader = new THREE.TextureLoader();
        textureLoader.load("sparkle4.jpg", function (tex) {
          tex.wrapS = THREE.RepeatWrapping;
          tex.wrapT = THREE.RepeatWrapping;

          texturedTrailMaterial = THREE.TrailRenderer.createTexturedMaterial();
          texturedTrailMaterial.uniforms.texture.value = tex;

          continueInitialization();

          if (callback) {
            callback();
          }
        });

        function continueInitialization() {
          trailHeadGeometry = circlePoints;
          trailMaterial = baseTrailMaterial;
          initializeTrail();
        }
      }

      function updateTrailShape() {
        setTrailShapeFromOptions();
        initializeTrail();
      }

      function updateTrailTextureTileSize() {
        trailMaterial.uniforms.textureTileFactor.value.set(
          options.textureTileFactorS,
          options.textureTileFactorT
        );
      }

      function updateTrailColors() {
        trailMaterial.uniforms.headColor.value.set(
          options.headRed,
          options.headGreen,
          options.headBlue,
          options.headAlpha
        );
        trailMaterial.uniforms.tailColor.value.set(
          options.tailRed,
          options.tailGreen,
          options.tailBlue,
          options.tailAlpha
        );
      }

      function updateTrailDepthWrite() {
        trailMaterial.depthWrite = options.depthWrite;
      }

      var updateTrailTarget = (function updateTrailTarget() {
        var tempQuaternion = new THREE.Quaternion();

        var baseForward = new THREE.Vector3(0, 0, -1);
        var tempForward = new THREE.Vector3();
        var tempUp = new THREE.Vector3();

        var tempRotationMatrix = new THREE.Matrix4();
        var tempTranslationMatrix = new THREE.Matrix4();

        var currentTargetPosition = new THREE.Vector3();
        var lastTargetPosition = new THREE.Vector3();

        var currentDirection = new THREE.Vector3();
        var lastDirection = new THREE.Vector3();

        var lastRotationMatrix = new THREE.Matrix4();

        return function updateTrailTarget(time) {
          if (time - lastTrailUpdateTime > 10) {
            trail.advance();
            lastTrailUpdateTime = time;
          } else {
            trail.updateHead();
          }

          tempRotationMatrix.identity();
          tempTranslationMatrix.identity();

          var scaledTime = time * 0.001;
          var areaScale = 100;

          //   lastTargetPosition.copy(currentTargetPosition);

          // mouse position
          window.onmousemove = (event) => {
            var vec = new THREE.Vector3(); // create once and reuse
            var pos = new THREE.Vector3(); // create once and reuse

            vec.set(
              (event.clientX / window.innerWidth) * 2 - 1,
              -(event.clientY / window.innerHeight) * 2 + 1,
              0
            );

            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            var distance = -camera.position.z / vec.z;
            let newPos = pos
              .copy(camera.position)
              .add(vec.multiplyScalar(distance));

            currentTargetPosition.copy(newPos);

            lastDirection.copy(currentDirection);

            currentDirection.copy(currentTargetPosition);
            currentDirection.sub(lastTargetPosition);
            currentDirection.normalize();

            // tempUp.crossVectors(currentDirection, baseForward);
            // var angle = baseForward.angleTo(currentDirection);

            // if (Math.abs(angle) > 0.01 && tempUp.lengthSq() > 0.001) {
            //   tempQuaternion.setFromUnitVectors(baseForward, currentDirection);
            //   tempQuaternion.normalize();
            //   tempRotationMatrix.makeRotationFromQuaternion(tempQuaternion);
            //   lastRotationMatrix.copy(tempRotationMatrix);
            // }

            tempTranslationMatrix.makeTranslation(
              currentTargetPosition.x,
              currentTargetPosition.y,
              currentTargetPosition.z
            );
            // tempTranslationMatrix.multiply(tempRotationMatrix);

            // trailTarget.matrix.identity();
            trailTarget.applyMatrix(tempTranslationMatrix);
            trailTarget.updateMatrixWorld();
          };

          //   currentTargetPosition.x = Math.sin(scaledTime) * areaScale;
          //   currentTargetPosition.y = Math.sin(scaledTime * 1.1) * areaScale;
          //   currentTargetPosition.z = Math.sin(scaledTime * 1.6) * areaScale;

          //   lastDirection.copy(currentDirection);

          //   currentDirection.copy(currentTargetPosition);
          //   currentDirection.sub(lastTargetPosition);
          //   currentDirection.normalize();

          //   tempUp.crossVectors(currentDirection, baseForward);
          //   var angle = baseForward.angleTo(currentDirection);

          //   if (Math.abs(angle) > 0.01 && tempUp.lengthSq() > 0.001) {
          //     tempQuaternion.setFromUnitVectors(baseForward, currentDirection);
          //     tempQuaternion.normalize();
          //     tempRotationMatrix.makeRotationFromQuaternion(tempQuaternion);
          //     lastRotationMatrix.copy(tempRotationMatrix);
          //   }

          //   tempTranslationMatrix.makeTranslation(
          //     currentTargetPosition.x,
          //     currentTargetPosition.y,
          //     currentTargetPosition.z
          //   );
          //   tempTranslationMatrix.multiply(tempRotationMatrix);

          //   trailTarget.matrix.identity();
          //   trailTarget.applyMatrix(tempTranslationMatrix);
          //   trailTarget.updateMatrixWorld();
        };
      })();

      function initializeTrail() {
        trail.initialize(
          trailMaterial,
          Math.floor(options.trailLength),
          options.dragTexture ? 1.0 : 0.0,
          0,
          trailHeadGeometry,
          trailTarget
        );
        updateTrailColors();
        updateTrailTextureTileSize();
        updateTrailDepthWrite();
        trail.activate();
      }

      function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, 1.0, 2, 2000);
        scene.add(camera);
        resetCamera();
      }

      function onWindowResize() {
        getScreenDimensions();
        renderer.setSize(screenWidth, screenHeight);
        resetCamera();
      }

      function getScreenDimensions() {
        screenWidth = window.innerWidth;
        screenHeight = window.innerHeight;
      }

      function resetCamera() {
        getScreenDimensions();
        camera.aspect = screenWidth / screenHeight;
        camera.updateProjectionMatrix();
        camera.position.set(0, 200, 400);
        camera.lookAt(scene.position);
      }

      function animate() {
        requestAnimationFrame(animate);
        update();
        render();
      }

      function update() {
        var time = performance.now();

        if (!options.pauseSim) updateTrailTarget(time);
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
